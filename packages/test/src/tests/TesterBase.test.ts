import { doesNotReject, ok, rejects } from "node:assert";
import { Adapter, IErrorHandler, MissingPropertyAccessError, NameofError, UnsupportedNodeError } from "@typescript-nameof/common";
import { createSandbox, match, SinonSandbox, SinonStubbedInstance } from "sinon";
import { nameOf } from "ts-nameof-proxy";
import { INameofOutput } from "../INameofOutput.js";
import { TesterBase } from "../TesterBase.js";

/**
 * Registers tests for the {@linkcode TesterBase} class.
 */
export function TesterBaseTests(): void
{
    suite(
        TesterBase.name,
        () =>
        {
            /**
             * Provides an implementation of the {@linkcode TesterBase} class for testing.
             */
            class TestTester extends TesterBase<any, any>
            {
                /**
                 * @inheritdoc
                 *
                 * @param code
                 * The code to transform.
                 *
                 * @returns
                 * The transformed representation of the specified {@linkcode code}.
                 */
                public override Transform(code: string): Promise<INameofOutput>
                {
                    return super.Transform(code);
                }

                /**
                 * @inheritdoc
                 *
                 * @param code
                 * The code to transform.
                 *
                 * @param errorHandler
                 * A component for reporting errors.
                 *
                 * @returns
                 * The transformed representation of the specified {@linkcode code}.
                 */
                public override async Run(code: string, errorHandler?: IErrorHandler<any, any> | undefined): Promise<string>
                {
                    return "";
                }

                /**
                 * @inheritdoc
                 *
                 * @param code
                 * The code to pre-process.
                 *
                 * @returns
                 * Pre-processes the specified {@linkcode code}.
                 */
                public override Preprocess(code: string): Promise<string>
                {
                    return super.Preprocess(code);
                }

                /**
                 * @inheritdoc
                 *
                 * @param input
                 * The input of the transformation.
                 *
                 * @param expected
                 * The expected output of the transformation.
                 */
                public override async Assert(input: string, expected: string): Promise<void>
                {
                    await super.Assert(input, expected);
                }

                /**
                 * @inheritdoc
                 *
                 * @param output
                 * The output generated by the transformation.
                 *
                 * @param expected
                 * The expected code.
                 */
                public override async CodeEquals(output: string | undefined, expected: string | undefined): Promise<void>
                {
                    await super.CodeEquals(output, expected);
                }

                /**
                 * @inheritdoc
                 *
                 * @param input
                 * The input of the transformation.
                 *
                 * @param errorClasses
                 * The classes of the expected error.
                 */
                public override async AssertError(input: string, ...errorClasses: Array<(new (...args: any[]) => Error)>): Promise<void>
                {
                    await super.AssertError(input, ...errorClasses);
                }
            }

            let sandbox: SinonSandbox;
            let tester: SinonStubbedInstance<TestTester>;
            let adapter: SinonStubbedInstance<Adapter<any, any, any>>;

            suiteSetup(
                () =>
                {
                    sandbox = createSandbox();
                });

            setup(
                () =>
                {
                    tester = new TestTester() as SinonStubbedInstance<TestTester>;
                    adapter = sandbox.createStubInstance(Adapter);
                });

            teardown(
                () =>
                {
                    sandbox.restore();
                });

            suite(
                nameOf<TestTester>((tester) => tester.Transform),
                () =>
                {
                    test(
                        "Checking whether the code is pre-processed before running the transformer…",
                        async () =>
                        {
                            let value = "who dis?";
                            sandbox.stub(tester, "Run");
                            sandbox.stub(tester, "Preprocess");
                            tester.Preprocess.resolves(value);
                            await tester.Transform("");
                            ok(tester.Run.calledOnce);
                            ok(tester.Run.calledWith(value, match.any));
                        });
                });

            suite(
                nameOf<TestTester>((tester) => tester.Assert),
                () =>
                {
                    let input: string;
                    let invalid: string;
                    let expected: string;
                    let output: string | undefined;

                    setup(
                        () =>
                        {
                            input = "What are you!?";
                            expected = "idiot";
                            invalid = "sandwich";

                            sandbox.stub(tester, "Transform").callsFake(
                                async () =>
                                {
                                    return {
                                        errors: [],
                                        output
                                    };
                                });
                        });

                    test(
                        "Checking whether the output of the transformation can be asserted…",
                        async () =>
                        {
                            output = invalid;
                            await rejects(() => tester.Assert(input, expected));
                            output = expected;
                            await doesNotReject(() => tester.Assert(input, expected));
                        });
                });

            suite(
                nameOf<TestTester>((tester) => tester.CodeEquals),
                () =>
                {
                    test(
                        "Checking whether the code is formatted for checking for equality…",
                        async () =>
                        {
                            await doesNotReject(() => tester.CodeEquals("    let x = 10;", "  let     x = 10 ;"));
                            await rejects(() => tester.CodeEquals("nameof(console)", '"console"'));
                        });
                });

            suite(
                nameOf<TestTester>((tester) => tester.AssertError),
                () =>
                {
                    let errors: Error[] = [];

                    setup(
                        () =>
                        {
                            sandbox.stub(tester, "Transform");

                            tester.Transform.callsFake(
                                async () =>
                                {
                                    return {
                                        errors,
                                        output: ""
                                    };
                                });
                        });

                    test(
                        "Checking whether the occurrence of errors can be asserted…",
                        async () =>
                        {
                            await rejects(() => tester.AssertError("hello world"));
                            errors = [new Error()];
                            await doesNotReject(() => tester.AssertError("is this a sin?"));
                        });

                    test(
                        "Checking whether the errors can be asserted by their names…",
                        async () =>
                        {
                            let action = async (): Promise<void> =>
                            {
                                await tester.AssertError(
                                    "Are you feeling it now, Mr. Krabs?",
                                    UnsupportedNodeError,
                                    MissingPropertyAccessError);
                            };

                            await rejects(() => action());
                            errors = [new Error()];
                            await rejects(() => action());
                            errors = [new NameofError(UnsupportedNodeError.name, "")];
                            await doesNotReject(() => action());
                            errors = [new NameofError(MissingPropertyAccessError.name, "")];
                            await doesNotReject(() => action());

                            errors = [
                                new NameofError(UnsupportedNodeError.name, ""),
                                new NameofError(MissingPropertyAccessError.name, "")
                            ];

                            await doesNotReject(() => action());
                        });
                });
        });
}
